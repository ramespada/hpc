<h1 id="makefiles">Makefiles</h1>

<blockquote>
  <p>make es una herramienta para mantener y gestionar programas complejos. Esta herramienta determina automáticamente que partes de un programa necesita ser recompilado e invoca comandos para su recompilación.</p>
</blockquote>

<p>El programa <code class="language-plaintext highlighter-rouge">make</code> lee las instrucciones de un archivo de texto llamado <code class="language-plaintext highlighter-rouge">Makefile</code>.
El <code class="language-plaintext highlighter-rouge">Makefile</code> contiene una serie de <em>reglas</em> que determinan que las dependencias de las distinas partes del programa para ser recompialado.</p>

<p><code class="language-plaintext highlighter-rouge">make</code> permite atuomatizar el proceso de construir un programa y realizar otras acciones con dependencias.</p>

<p>Un <code class="language-plaintext highlighter-rouge">Makefile</code> contiene:</p>
<ul>
  <li>relgas de dependencia</li>
  <li>macros</li>
  <li>reglas implicitas (sufijos)</li>
</ul>

<h2 id="reglas-de-dependencia">Reglas de dependencia</h2>

<p>Un makefile consiste en una serie de reglas con la siguiente estructura:</p>
<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">target</span><span class="o">:</span> <span class="nf">prerequisitos</span>
	comando
	comando
	comando
</code></pre></div></div>

<p>El <code class="language-plaintext highlighter-rouge">target</code> es el nombre de un archivo separado por espacios, tipicamente hay uno por regla. Los <code class="language-plaintext highlighter-rouge">prerequisitos</code> son tambien nombres de archivos separados por espacios. Estos archivos deben existir para que se ejecuten los comandos.
Los comandos son lineas de ejecución con sintaxis de shell que generalmente involucra a los <code class="language-plaintext highlighter-rouge">prerequisitos</code> y suelen ser usadas para crear el <code class="language-plaintext highlighter-rouge">target</code>.</p>

<h3 id="ejemplo-1-hola-mundo">Ejemplo 1: “Hola Mundo!”</h3>

<p>Creemos un <code class="language-plaintext highlighter-rouge">Makefile</code> con el siguiente contenido:</p>
<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">hola</span><span class="o">:</span>
	<span class="nb">echo</span> <span class="s2">"Hola mundo!"</span>
</code></pre></div></div>
<p>En este ejemplo tenemos un target, sin prerequisitos, y un comando. Para ejecutar el <code class="language-plaintext highlighter-rouge">Makefile</code> escribimos:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make
<span class="nb">echo</span> <span class="s2">"Hola mundo!"</span>
Hola mundo!
</code></pre></div></div>
<p>vemos que se imprime el comando, y también se ejecuta el comando.</p>

<p>Si queremos que se imprima el mensaje, pero no el comando, tenemos que agregar en el Makefile el simbolo de <code class="language-plaintext highlighter-rouge">@</code> antes del comando:</p>
<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">hola</span><span class="o">:</span>
	<span class="p">@</span><span class="nb">echo</span> <span class="s2">"Hola mundo!"</span>
</code></pre></div></div>
<p>Si volvemos a ejecutarlo va a mostrar el mensaje “Hola mundo!” y va continuar haciendo lo mismo, siempre y cuando no exista el archivo <code class="language-plaintext highlighter-rouge">hola</code>. Veamos que ocurre si por ejemplo cremos un archivo <code class="language-plaintext highlighter-rouge">hola</code> y luego ejecutamos <code class="language-plaintext highlighter-rouge">make</code>:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">touch </span>hola
<span class="nv">$ </span>make
make: <span class="s1">'hola'</span> is up to date.
</code></pre></div></div>
<p>nos dice que <code class="language-plaintext highlighter-rouge">hola</code> está actualizado, ya que el archivo objetivo existe y sus depndencias/prerequisitos (en este caso niguno) no han sido alterados desde su creación.</p>

<h3 id="ejemplo-2-compilación-de-un-programa">Ejemplo 2: Compilación de un programa</h3>

<p>Imaginemos que tenemos un programa en <code class="language-plaintext highlighter-rouge">C</code> que consiste en dos archivos: <code class="language-plaintext highlighter-rouge">main.c</code> y <code class="language-plaintext highlighter-rouge">scale.c</code> cuyo contenido es:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>main.c
<span class="c">#include &lt;stdio.h&gt;</span>
int scale<span class="o">(</span>int x<span class="o">)</span><span class="p">;</span>
int main<span class="o">(){</span>
	int <span class="nv">x</span><span class="o">=</span>5,y<span class="p">;</span>
	<span class="nv">y</span><span class="o">=</span>scale<span class="o">(</span>x<span class="o">)</span><span class="p">;</span>
	<span class="nb">printf</span><span class="o">(</span><span class="s2">"scale(%d)=%d</span><span class="se">\n</span><span class="s2">"</span>,x,y<span class="o">)</span><span class="p">;</span>
	<span class="k">return </span>0<span class="p">;</span>
<span class="o">}</span>
<span class="nv">$ </span><span class="nb">cat </span>scale.c
int scale<span class="o">(</span>int x<span class="o">){</span>
	<span class="k">return</span><span class="o">(</span>5<span class="k">*</span>x<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Notar que <code class="language-plaintext highlighter-rouge">main.c</code> depende usa la función <code class="language-plaintext highlighter-rouge">scale</code> de <code class="language-plaintext highlighter-rouge">scale.c</code>.</p>

<p>Si quisieramos compilar este programa tendramos que realizar los siguientes pasos:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-o</span> main main.c scale.c
</code></pre></div></div>
<p>ó alternativamente:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc <span class="nt">-c</span> main.c	
<span class="nv">$ </span><span class="nb">ls</span>                      <span class="c">#verificamos que se creo main.o</span>
main.c  main.o  scale.c
<span class="nv">$ </span>gcc <span class="nt">-c</span> scale.c
<span class="nv">$ </span><span class="nb">ls</span>                      <span class="c">#verificamos que se creo scale.o</span>
main.c  main.o  scale.c  scale.o
<span class="nv">$ </span>gcc <span class="nt">-o</span> main main.o scale.o
<span class="nv">$ </span><span class="nb">ls</span>                      <span class="c">#verificamos que se creo main</span>
main main.c  main.o  scale.c  scale.o
</code></pre></div></div>
<p>esta segunda opción es más eficientes cuando trabjamos con programas grandes. Esto se debe a que en las primeras lineas estamos compilando el programa y creando los archivos <code class="language-plaintext highlighter-rouge">*.o</code> que son programas compilados pero no linkeados, mientras que el ultimo comando los linkea.
Compilar es un proceso lento, y linkear programas compilados un proceso rápido. Si realizamos una modificación en un módulo del programa, no tiene sentido volver a compilar todo cuando podríamos mejor recompilar solo el módulo modificado y luego linkear todo junto.</p>

<p>Dicho esto, se puede ver que si bien la segunda alternativa es conveniente, es tedioso y cuando un programa se vuelve complejo hay que considerar constantemente cuales son las dependencias entre módulos. Una solución a esto es usar <code class="language-plaintext highlighter-rouge">Makefiles</code>:</p>

<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">main</span><span class="o">:</span> <span class="nf">main.o scale.o</span>
	gcc <span class="nt">-o</span> main main.o scale.o
<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c</span>
	gcc <span class="nt">-c</span> main.c
<span class="nl">scale.o</span><span class="o">:</span> <span class="nf">scale.c</span>
	gcc <span class="nt">-c</span> scale.c
</code></pre></div></div>

<p>Luego para compilar el programa solo necesitamos ejecutar <code class="language-plaintext highlighter-rouge">make</code>.</p>

<p>Es muy común que los <code class="language-plaintext highlighter-rouge">Makefiles</code> contangan una regla llamada <code class="language-plaintext highlighter-rouge">clean</code> que borre automaticamente todos los archivos intermedios creados en la compilación, de manera que si alguien quiere compilar en una computadora con otras características pueda realizar el procedimiento completo de compilación y no queden archivos remanentes que puedan generar errores.</p>

<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">main</span><span class="o">:</span> <span class="nf">main.o scale.o</span>
	gcc <span class="nt">-o</span> main main.o scale.o
<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c</span>
	gcc <span class="nt">-c</span> main.c
<span class="nl">scale.o</span><span class="o">:</span> <span class="nf">scale.c</span>
	gcc <span class="nt">-c</span> scale.c
<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm </span>main main.o scale.o 
</code></pre></div></div>

<p>notar que <code class="language-plaintext highlighter-rouge">clean</code> no tiene prerequisitos, para ejecutar esa regla:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make clean
<span class="nv">$ </span><span class="nb">ls
</span>main.c Makefile scale.c
</code></pre></div></div>

<p>Por último, supongamos que queremos compilar el programa con algun flag en particular, por ejemplo <code class="language-plaintext highlighter-rouge">-g</code>, para esto podemos definir una variable antes de las reglas de la siguiente forma:</p>
<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span><span class="o">=</span> <span class="nt">-g</span>
<span class="nl">main</span><span class="o">:</span> <span class="nf">main.o scale.o</span>
	gcc <span class="nv">$(CFLAGS)</span> <span class="nt">-o</span> main main.o scale.o
<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c</span>
	gcc <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> main.c
<span class="nl">scale.o</span><span class="o">:</span> <span class="nf">scale.c</span>
	gcc <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> scale.c
<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm </span>main main.o scale.o 
</code></pre></div></div>

<h2 id="sintaxis">Sintaxis:</h2>

<p>Asignaciones:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">=</code> (asignación):<code class="language-plaintext highlighter-rouge">SRCS = main.c</code></li>
  <li><code class="language-plaintext highlighter-rouge">:=</code> (expansión):<code class="language-plaintext highlighter-rouge">SRCS := $(wildcard *.c)</code></li>
  <li><code class="language-plaintext highlighter-rouge">:=</code> (expansión):<code class="language-plaintext highlighter-rouge">SRCS := $(shell find . -name '*.c')</code></li>
  <li><code class="language-plaintext highlighter-rouge">:=</code> (expansión):<code class="language-plaintext highlighter-rouge">SRCS := $(BAR) # Comment</code></li>
  <li><code class="language-plaintext highlighter-rouge">!=</code> (shell output):<code class="language-plaintext highlighter-rouge">SRCS != find . -name '*.c'</code></li>
  <li><code class="language-plaintext highlighter-rouge">+=</code> (append to):<code class="language-plaintext highlighter-rouge">CC_FLAGS += -Wextra</code></li>
  <li><code class="language-plaintext highlighter-rouge">?=</code> (asignación condicional):<code class="language-plaintext highlighter-rouge">CFLAGS ?= $(CC_FLAGS)</code></li>
</ul>

<p>Funciones:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$(SRCS:.c=.o)</code> reemplaza “.c” por “.o” en SRCS</li>
  <li><code class="language-plaintext highlighter-rouge">$addprefix build/,$(OBJS))</code> agrega “build/” a todos los archivos en OBJS</li>
  <li><code class="language-plaintext highlighter-rouge">$(if ..) $(or ..) $(and..)</code></li>
  <li><code class="language-plaintext highlighter-rouge">$(foreach var, list,text )</code></li>
  <li><code class="language-plaintext highlighter-rouge">$(value (VARIABLE))</code></li>
  <li><code class="language-plaintext highlighter-rouge">$(shell ..)</code></li>
  <li><code class="language-plaintext highlighter-rouge">$(error ..)</code></li>
  <li><code class="language-plaintext highlighter-rouge">$(warning ..)</code></li>
  <li><code class="language-plaintext highlighter-rouge">$(info ..)</code></li>
</ul>

<h3 id="variables-automáticas">Variables automáticas</h3>
<p>Nomenclatura dentro de un comando:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">$@</code>: current target (útil cuando hay muchos target)</li>
  <li><code class="language-plaintext highlighter-rouge">$&lt;</code>: primer prerequisito.</li>
  <li><code class="language-plaintext highlighter-rouge">$^</code>: todos los prerequisitos.</li>
  <li><code class="language-plaintext highlighter-rouge">$?</code>: prerequisitos que hayan sido modificados.</li>
  <li><code class="language-plaintext highlighter-rouge">$|</code>: prerequisitos <em>order-only</em></li>
</ul>

<h3 id="phony"><code class="language-plaintext highlighter-rouge">.PHONY</code></h3>
<p><code class="language-plaintext highlighter-rouge">.PHONY: target</code> lo que hace es avisar a make que <code class="language-plaintext highlighter-rouge">target</code> no es un archivo y por lo tanto sirve para marcar reglas cuyo objetivo no es generar un archivo <code class="language-plaintext highlighter-rouge">target</code> sino simplemente ejecutar algunos comandos.</p>

<h3 id="dependencia-automática">Dependencia automática</h3>

